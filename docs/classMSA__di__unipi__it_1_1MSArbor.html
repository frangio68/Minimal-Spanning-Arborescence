<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MSArbor: MSArbor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MSArbor
   &#160;<span id="projectnumber">1.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMSA__di__unipi__it.html">MSA_di_unipi_it</a></li><li class="navelem"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html">MSArbor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classMSA__di__unipi__it_1_1MSArbor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MSArbor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Given a (complete) directed graph G = ( N , A ), with n = |N| nodes and m = |A| (= n ( n - 1 )) arcs, and arc costs C[ i , j ], the Minimal Spanning Arborescence problem (MSA) with root r requires to find a directed spanning tree (arborescence) of G rooted in r with minimal total cost, where the cost is the sum of the costs of the arcs belonging to the tree.  
 <a href="classMSA__di__unipi__it_1_1MSArbor.html#details">More...</a></p>

<p><code>#include &lt;MSArbor.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad0e8111a89356f79068cf55699bc21c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0e8111a89356f79068cf55699bc21c1"></a>
typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ad0e8111a89356f79068cf55699bc21c1">Index</a></td></tr>
<tr class="memdesc:ad0e8111a89356f79068cf55699bc21c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">arc or node index ( &gt;= 0 ) <br /></td></tr>
<tr class="separator:ad0e8111a89356f79068cf55699bc21c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3388eb329ff0551a0b86b6c67e33d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace3388eb329ff0551a0b86b6c67e33d8"></a>
typedef <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ad0e8111a89356f79068cf55699bc21c1">Index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a></td></tr>
<tr class="memdesc:ace3388eb329ff0551a0b86b6c67e33d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set (array) of indices <br /></td></tr>
<tr class="separator:ace3388eb329ff0551a0b86b6c67e33d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76aaabb20535c51a2752b93f6c38fe54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76aaabb20535c51a2752b93f6c38fe54"></a>
typedef const <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ad0e8111a89356f79068cf55699bc21c1">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a></td></tr>
<tr class="memdesc:a76aaabb20535c51a2752b93f6c38fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only Index <br /></td></tr>
<tr class="separator:a76aaabb20535c51a2752b93f6c38fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81575b2d4e4d5636b17170432150ae69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81575b2d4e4d5636b17170432150ae69"></a>
typedef <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a></td></tr>
<tr class="memdesc:a81575b2d4e4d5636b17170432150ae69"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only array <br /></td></tr>
<tr class="separator:a81575b2d4e4d5636b17170432150ae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c62c9d88f588bddf23f07660587ae6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5c62c9d88f588bddf23f07660587ae6"></a>
typedef short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#af5c62c9d88f588bddf23f07660587ae6">CNumber</a></td></tr>
<tr class="memdesc:af5c62c9d88f588bddf23f07660587ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc costs: since the cost matrix is re-used to store node names, it not should be (too) "smaller" than Index <br /></td></tr>
<tr class="separator:af5c62c9d88f588bddf23f07660587ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62409402be4e4b301e1a568f99f877be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62409402be4e4b301e1a568f99f877be"></a>
typedef <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#af5c62c9d88f588bddf23f07660587ae6">CNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a62409402be4e4b301e1a568f99f877be">CRow</a></td></tr>
<tr class="memdesc:a62409402be4e4b301e1a568f99f877be"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of costs <br /></td></tr>
<tr class="separator:a62409402be4e4b301e1a568f99f877be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dbefeeb08c3f63073622411893eb76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07dbefeeb08c3f63073622411893eb76"></a>
typedef const <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#af5c62c9d88f588bddf23f07660587ae6">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a></td></tr>
<tr class="memdesc:a07dbefeeb08c3f63073622411893eb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only cost <br /></td></tr>
<tr class="separator:a07dbefeeb08c3f63073622411893eb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab700102e9ba8bb6015be6818d4e99097"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab700102e9ba8bb6015be6818d4e99097"></a>
typedef <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a></td></tr>
<tr class="memdesc:ab700102e9ba8bb6015be6818d4e99097"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only cost array <br /></td></tr>
<tr class="separator:ab700102e9ba8bb6015be6818d4e99097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2bdabe13641282293ee33a8bc8592a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d2bdabe13641282293ee33a8bc8592a"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a5d2bdabe13641282293ee33a8bc8592a">FONumber</a></td></tr>
<tr class="memdesc:a5d2bdabe13641282293ee33a8bc8592a"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of objective function values; should be able to hold something like (max arc cost) times (max number of nodes) <br /></td></tr>
<tr class="separator:a5d2bdabe13641282293ee33a8bc8592a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5bc5b0016d66355cb7aebc9e3726ba41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a5bc5b0016d66355cb7aebc9e3726ba41">MSArbor</a> (<a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ad0e8111a89356f79068cf55699bc21c1">Index</a> nds)</td></tr>
<tr class="memdesc:a5bc5b0016d66355cb7aebc9e3726ba41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class: takes as parameter the number of nodes in the graph G.  <a href="#a5bc5b0016d66355cb7aebc9e3726ba41">More...</a><br /></td></tr>
<tr class="separator:a5bc5b0016d66355cb7aebc9e3726ba41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10bf4a6718578c9e0ca6755b7f649e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a5d2bdabe13641282293ee33a8bc8592a">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#aa10bf4a6718578c9e0ca6755b7f649e9">Solve</a> (<a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> C, <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a62409402be4e4b301e1a568f99f877be">CRow</a> RC=0)</td></tr>
<tr class="memdesc:aa10bf4a6718578c9e0ca6755b7f649e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method solves the Minimum Spanning Arborescence problem on the complete graph described in the vector C[], which is a vector of arc costs, ordered as follows:  <a href="#aa10bf4a6718578c9e0ca6755b7f649e9">More...</a><br /></td></tr>
<tr class="separator:aa10bf4a6718578c9e0ca6755b7f649e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ad3113996bcc70d1d95ce7b0383b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a96ad3113996bcc70d1d95ce7b0383b42">ReadPred</a> (void) const </td></tr>
<tr class="memdesc:a96ad3113996bcc70d1d95ce7b0383b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only vector describing the primal optimal solution of the problem, i.e., the "predecessor" function of the optimal MSA.  <a href="#a96ad3113996bcc70d1d95ce7b0383b42">More...</a><br /></td></tr>
<tr class="separator:a96ad3113996bcc70d1d95ce7b0383b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08c909a4c94a4fd08145fec2fdc80ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ae08c909a4c94a4fd08145fec2fdc80ed">GetU</a> (void) const </td></tr>
<tr class="memdesc:ae08c909a4c94a4fd08145fec2fdc80ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">These three methods describe the dual optimal solution of the problem (a good knowledge of the algorithm is required for understending their meaning).  <a href="#ae08c909a4c94a4fd08145fec2fdc80ed">More...</a><br /></td></tr>
<tr class="separator:ae08c909a4c94a4fd08145fec2fdc80ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9e65abfc841edc355d28652f827a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ad0e8111a89356f79068cf55699bc21c1">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#acf9e65abfc841edc355d28652f827a90">GetN</a> (void) const </td></tr>
<tr class="memdesc:acf9e65abfc841edc355d28652f827a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the problem (number of nodes).  <a href="#acf9e65abfc841edc355d28652f827a90">More...</a><br /></td></tr>
<tr class="separator:acf9e65abfc841edc355d28652f827a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:abb90ea9db697ed8a33d876e19d32a79e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb90ea9db697ed8a33d876e19d32a79e"></a>
static <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#abb90ea9db697ed8a33d876e19d32a79e">InINF</a> = 65535</td></tr>
<tr class="memdesc:abb90ea9db697ed8a33d876e19d32a79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the largest Index <br /></td></tr>
<tr class="separator:abb90ea9db697ed8a33d876e19d32a79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447d805d42511f6323bad797b06ef45f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a447d805d42511f6323bad797b06ef45f"></a>
static <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a447d805d42511f6323bad797b06ef45f">C_INF</a> = 32767</td></tr>
<tr class="memdesc:a447d805d42511f6323bad797b06ef45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the largest arc cost is C_INF - 2, as C_INF - 1 means "no arc is here" and C_INF is reserved <br /></td></tr>
<tr class="separator:a447d805d42511f6323bad797b06ef45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Given a (complete) directed graph G = ( N , A ), with n = |N| nodes and m = |A| (= n ( n - 1 )) arcs, and arc costs C[ i , j ], the Minimal Spanning Arborescence problem (MSA) with root r requires to find a directed spanning tree (arborescence) of G rooted in r with minimal total cost, where the cost is the sum of the costs of the arcs belonging to the tree. </p>
<p>This class solves MSA for r = n - 1 (the node with largest index) with a C++ implementation of the ARBOR algorithm [M. Fischetti and P.Toth, ORSA J. on Computing 5(4), 1993] for complete graphs.</p>
<p>Nodes and arc indices are defined to be of the public type <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ad0e8111a89356f79068cf55699bc21c1" title="arc or node index ( &gt;= 0 ) ">MSArbor::Index</a>, and arc costs are defined to be of the public type <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#af5c62c9d88f588bddf23f07660587ae6" title="type of arc costs: since the cost matrix is re-used to store node names, it not should be (too) &quot;smal...">MSArbor::CNumber</a>. These types, with the accompanying constants InINF and C_INF, are defined in the public types part of the class. By changing these definitions one can a) solve compilation problems due to different type or constant names in differend compilers, and b) use "small" data types, just large enough to fit the numbers in his/her instances, thereby (possibly) reducing the memory footprint of the object and increasing its efficiency. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5bc5b0016d66355cb7aebc9e3726ba41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html">MSArbor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ad0e8111a89356f79068cf55699bc21c1">Index</a>&#160;</td>
          <td class="paramname"><em>nds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of the class: takes as parameter the number of nodes in the graph G. </p>
<p>The actual graph is passed in <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#aa10bf4a6718578c9e0ca6755b7f649e9" title="This method solves the Minimum Spanning Arborescence problem on the complete graph described in the v...">Solve()</a> [see below], and different instances can be solved by calling <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#aa10bf4a6718578c9e0ca6755b7f649e9" title="This method solves the Minimum Spanning Arborescence problem on the complete graph described in the v...">Solve()</a> multiple times on the same <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html" title="Given a (complete) directed graph G = ( N , A ), with n = |N| nodes and m = |A| (= n ( n - 1 )) arcs...">MSArbor</a> object, as long as al the instances have the same number of nodes. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa10bf4a6718578c9e0ca6755b7f649e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a5d2bdabe13641282293ee33a8bc8592a">FONumber</a> Solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>RC</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method solves the Minimum Spanning Arborescence problem on the complete graph described in the vector C[], which is a vector of arc costs, ordered as follows: </p>
<ul>
<li>a sequence of n - 1 Backward Stars: BS[ 0 ], BS[ 1 ], .., BS[ n - 2 ];</li>
<li>arcs in each BS[ i ] are ordered in increasing index of tail node;</li>
</ul>
<p>Since nodes are numbered from 0 to n - 1, and the root is node n - 1, C[ i + n * j ] is the cost of ( i , j ). BS[ root ] does not exist.</p>
<p>Although the algorithm is developed with complete graphs in mind, it is possible to try solve non-complete instances by giving not-existent arcs the "plus infinity" cost C_INF - 1. If the costs of all other nodes are suitably smaller than that, then the optimal solution will avoid these arcs. However, if there is <em>no</em> feasible solution <em>not</em> using at least one arc with cost C_INF - 1, then the best possible unfeasible solution will be reported instead with no warning, so it is the user's responsibility to check feasibility if that is in doubt. Also, note that arcs should <em>never</em> be given cost C_INF, since that value is reserved for special use by the code.</p>
<p>If RC != 0 (= NULL), after that the Minimum Spanning Arborescence has been found its optimal arc reduced costs are written in RC, in the same format as the arc cost vector C.</p>
<dl class="section warning"><dt>Warning</dt><dd>the current implementation of the reduced cost computation is a "naive" one, which has an O(n^3) worst case complexity; a smarter O(n^2) implementation is possible, but it is not implemented as yet. Note that the MSA computation has an O(n^2) cost. </dd></dl>

</div>
</div>
<a class="anchor" id="a96ad3113996bcc70d1d95ce7b0383b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a81575b2d4e4d5636b17170432150ae69">MSArbor::cIndex_Set</a> ReadPred </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only vector describing the primal optimal solution of the problem, i.e., the "predecessor" function of the optimal MSA. </p>
<p>For each node i = 0, ..., n - 2, j = <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#a96ad3113996bcc70d1d95ce7b0383b42" title="Returns a read-only vector describing the primal optimal solution of the problem, i...">ReadPred()</a>[ i ] is the predecessor of i in the spanning tree, and therefore arc (i, j) belongs to the optimal solution. The root has no predecessor, hence the entry n - 1 of the returned vector should not be checked. </p>

</div>
</div>
<a class="anchor" id="ae08c909a4c94a4fd08145fec2fdc80ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ab700102e9ba8bb6015be6818d4e99097">MSArbor::cCRow</a> GetU </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These three methods describe the dual optimal solution of the problem (a good knowledge of the algorithm is required for understending their meaning). </p>
<p>The dual optimal solution is described in terms of at most 2 n - 2 sets of nodes, arranged in a tree structure (called the "auxiliary tree") and with a dual variable attached to each. GetM() and ReadAux() describe the topology of the auxiliary tree: GetM() returns the number of its nodes, while ReadAux()[ i ] is the predecessor function of the tree. Note that the tree does not include a dummy root node, thus the sons of the dummy root have predecessor InINF. Finally, <a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ae08c909a4c94a4fd08145fec2fdc80ed" title="These three methods describe the dual optimal solution of the problem (a good knowledge of the algori...">GetU()</a>[ i ] is the value of the optimal dual variable associated with the set (node of the auxiliary tree) i. </p>

</div>
</div>
<a class="anchor" id="acf9e65abfc841edc355d28652f827a90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMSA__di__unipi__it_1_1MSArbor.html#ad0e8111a89356f79068cf55699bc21c1">MSArbor::Index</a> GetN </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the problem (number of nodes). </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
